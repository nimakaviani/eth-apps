'use strict';

const solc = require('solc');

/**
 * Compile and deploy smart contracts.
 */
class Deployer {
    /**
     * Constuct a new instance.
     *
     * @param {Object} config Configuration.
     * @param {Object} config.web3 A `Web3` instance.
     * @param {Object} config.address Address from which the contracts should be deployed
     * @param {String} [config.password] Optional password associated with the address.
     * @param {Number} config.gas Gas amount to spend in every transaction.
     */
    constructor(config) {
        this.web3 = config.web3;
        this.address = config.address;
        this.password = config.password;
        this.gas = config.gas ? config.gas : 500000;
    }

    /**
     * Compile and deploy contracts on the Ethereum blockchain.
     * @param {Object} sources Configuration.
     * @param {Object} paramsConstructors initial values to be used at constructor level.
     * @param {string[]} deployments name of the contracts that has to be deployed.
     * @return {Promise} Resolves if successful.
     */
    deployContracts(sources, paramsConstructors, deployments) {
        return Promise.resolve()
            .then(() => this._sanitizeValues(sources, deployments))
            .then(() => this._unlockAccountIfNeeded())
            .then(() => {
                this._log('Debug', 'Compiling contracts');

                if (this.cache) {
                    return this.cache;
                } else {
                    const compilation = solc.compile({ sources });
                    this.cache = compilation;
                    return compilation;
                }
            })
            .then((compilation) => {
                const errors = compilation.errors;
                if (errors) {
                    this._log('Error', `Error encounter while trying to unlock account ${errors}`);
                    throw new Error(errors);
                }
                return compilation;
            })
            .then((compilation) => {
                this._log('Debug', 'Contracts compiled');

                const promises = [];

                Object.keys(compilation.contracts).map((key) => {
                    const deploy = deployments.some(deployment => deployment === key);
                    if (!deploy) return null;

                    const contract = compilation.contracts[key];
                    const paramsConstructor = paramsConstructors[key];
                    contract.abi = JSON.parse(contract.interface);

                    const promise = this._deployContract(contract.abi, contract.bytecode,
                        key, paramsConstructor)
                        .then((address) => {
                            contract.address = address;
                            contract.name = key;
                            return contract;
                        });

                    return promises.push(promise);
                });

                return Promise.all(promises).then((contracts) => {
                    const refactored = {};
                    contracts.forEach((contract) => {
                        refactored[contract.name] = contract;
                    });
                    return refactored;
                });
            });
    }

    /**
     * Callback for logs.
     *
     * @callback Listener
     * @param {String} level The severity of the message.
     * @param {String} message.
     */

    /**
     * Listen to _log outputs.
     * @param {Listener} listener .
     */
    logs(listener) {
        this.logger = listener;
    }

    _sanitizeValues(sources, deployments) {
        if (!this.web3) {
            this._log('Error', 'A valid web3 instance is required');
            throw new Error('A valid web3 instance is required');
        }

        if (!this.web3.isAddress(this.address)) {
            this._log('Error', 'A valid address is required');
            throw new Error('A valid address is required');
        }

        if (Object.keys(sources).length === 0 && sources.constructor === Object) {
            this._log('Error', 'Smart contract sources is required');
            throw new Error('Smart contract sources is required');
        }

        if (!deployments || deployments.length === 0) {
            this._log('Error', 'At least one smart contract requires to be deployed');
            throw new Error('At least one smart contract requires to be deployed');
        }
    }

    _unlockAccountIfNeeded() {
        return new Promise((resolve, reject) => {
            if (!this.password) resolve();

            this._log('Debug', `Unlocking account ${this.address}`);
            this.web3.personal.unlockAccount(this.address, this.password, (error) => {
                if (error) {
                    this._log('Error', `Error encounter while trying to unlock account ${error}`);
                    return reject(error);
                }

                this._log('Debug', 'Account unlocked');
                return resolve();
            });
        });
    }

    _deployContract(abi, bytecode, name, paramsConstructor) {
        this._log('Debug', `Deploying contract ${name}`);
        return new Promise((resolve, reject) => {
            const contract = this.web3.eth.contract(abi);
            const safeParams = paramsConstructor || [];
            contract.new(...safeParams.concat([{
                data: bytecode,
                from: this.address,
                gas: this.gas
            }, (error, res) => {
                if (error) {
                    this._log('Error', `Error encounter while trying to deploy contract ${name}. ${error}`);
                    return reject(error);
                }

                if (res.address) {
                    this._log('Debug', `${name} deployed with address ${res.address}`);
                    return resolve(res.address);
                }

                return this._log('Debug', `${name} waiting for transaction with hash ${res.transactionHash}`);
            }]));
        });
    }

    _log(level, message) {
        if (!this.logger) return;
        this.logger(level, message);
    }
}

module.exports = Deployer;

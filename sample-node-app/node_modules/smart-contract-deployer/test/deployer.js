"use strict";

describe('Deployer', () => {
    const chai = require("chai");
    const chaiAsPromised = require("chai-as-promised");
    chai.use(chaiAsPromised);
    chai.should();
    const expect = chai.expect;
    const assert = chai.assert;
    const Promise = require('bluebird');
    const TestRPC = require("ethereumjs-testrpc");
    const Web3 = require('web3');
    const web3 = new Web3(TestRPC.provider());
    const Deployer = require('../src/index');
    var address;
    var contractD;

    before(() => {
        const Promise = require('bluebird');
        Promise.promisifyAll(web3.eth);
        return web3.eth.getAccountsAsync()
            .then(accounts => {
                address = accounts[0];
            });
    });

    it('A valid web3 instance is required', () => {
        const deployer = new Deployer({
            address: address
        });

        return deployer.deployContracts({})
            .should.eventually.be.rejectedWith('A valid web3 instance is required');
    });

    it('A valid address is required', () => {
        const deployer = new Deployer({
            web3: web3
        });

        return deployer.deployContracts({})
            .should.eventually.be.rejectedWith('A valid address is required');
    });

    it('Smart contract sources is required', () => {
        const deployer = new Deployer({
            web3: web3,
            address: address
        });

        return deployer.deployContracts({})
            .should.eventually.be.rejectedWith('Smart contract sources is required');
    });

    it('At least one smart contract requires to be deployed', () => {
        const deployer = new Deployer({
            web3: web3,
            address: address
        });

        return deployer.deployContracts([{}])
            .should.eventually.be.rejectedWith('At least one smart contract requires to be deployed');
    });

    it('When password is supplied try to unlock account', () => {
        const deployer = new Deployer({
            web3: web3,
            address: address,
            password: 'aPassword'
        });

        return deployer.deployContracts([{}], [{}], [''])
            .should.eventually.be.rejectedWith('RPC method personal_unlockAccount not supported');
    });

    it('Compile and deploy contracts', () => {
        const deployer = new Deployer({
            web3: web3,
            address: address
        });

        const fs = require('fs');

        const sources = {
            'ContractA.sol': fs.readFileSync('./test/contracts/ContractA.sol', 'utf8'),
            'ContractB.sol': fs.readFileSync('./test/contracts/ContractB.sol', 'utf8'),
            'ContractD.sol': fs.readFileSync('./test/contracts/ContractD.sol', 'utf8')
        };

        const paramsConstructor = {'ContractD': ['a', 'b', 'c']};
        const deployments = ['ContractB', 'ContractD', 'c'];

        return deployer.deployContracts(sources, paramsConstructor, deployments)
            .then(contracts => {
                expect(contracts).to.not.have.property('ContractA');
                expect(contracts.ContractB).to.have.property('abi');
                expect(contracts.ContractB).to.have.property('address').with.length(42);
                expect(contracts.ContractD).to.have.property('abi');
                expect(contracts.ContractD).to.have.property('address').with.length(42);
                contractD = web3.eth.contract(contracts.ContractD.abi).at(contracts.ContractD.address);
                Promise.promisifyAll(contractD);
            });
    }).timeout(15000);

    it('Verify constructor values contractD', () => {
        return Promise.join(contractD.getAAsync(), contractD.getBAsync(), contractD.getCAsync()).then(output => {
            assert.equal(output[0].valueOf(), 'a');
            assert.equal(output[1].valueOf(), 'b');
            assert.equal(output[2].valueOf(), 'c');
        });
    });

    it('Compile with errors', () => {
        const deployer = new Deployer({
            web3: web3,
            address: address
        });

        const fs = require('fs');

        const sources = {
            'ContractA.sol': fs.readFileSync('./test/contracts/ContractA.sol', 'utf8'),
            'ContractC.sol': fs.readFileSync('./test/contracts/ContractC.sol', 'utf8')
        }

        const message = 'ContractC.sol:16:5: Error: Function with same name and arguments defined twice.\n    function greet() constant returns (string) {\n    ^\nSpanning multiple lines.\nOther declaration is here: ContractC.sol:12:5: \n    function greet() constant returns (string) {\n    ^\nSpanning multiple lines.\n\n';
        return deployer.deployContracts(sources, {}, [''])
            .should.eventually.be.rejectedWith(message);
    }).timeout(15000);
});